package practice.complexity;

import java.util.Arrays;


public class ComplexityApp {
    public static void main(String[] args) {
 /*   задаем простой массив целых чисел
      будем выполнять с ним различные операции (вычисление среднего, сложение элементов, поиск элемента, поиск мин и макс, сортировка)
      оценим вычислительную сложность алгоритма
 */
        int[] arr = {-24, 7, -67, 15, 8, 93, 1};

        //вычисление среднего значения
        /*
        - узнать длину массива
        - в цикле складываем элементы
        - сумму делим на кол-во элементов
         */
        int sum = 0;
        for (int i = 0; i < arr.length; i++) {
            sum += arr[i]; //берем по одному элементу и добавляем к сложению - здесь растет кол-во операций
        }
        double avg = (double) sum / arr.length; //кастинг в другой тип (double)
        System.out.println("Average value: " + avg);

        // Что будет происходить при росте кол-ва элементов массива?
        // Это линейная сложность - так как кол-во операций прямо пропорционально кол-ву элементов массива.
        // O(n) - это линейная сложность данного алгоритма

        // поиск элемента
        // - если пробегаем по массиву, то сложность линейная O(n)
        // - если бинарный поиск

       /* Arrays.sort(arr); // сортируем целые числа - оценим отдельно
        System.out.println(Arrays.toString(arr));
        int index = Arrays.binarySearch(arr, -67); //не найдет элемент -67 так как нужна сортировка comparator
        System.out.println(index);

        index = Arrays.binarySearch(arr, 93);
        System.out.println(index);

        index = Arrays.binarySearch(arr, -100);
        System.out.println(index);
*/
        // При 8 элементов - 3 итераций деления массива
        // при 16 элементов - 4 итераций
        //......
        // При 1024 элементов - 10 итераций
        // При 2048 элементов - 11 итераций
        // O(log(n)) - это логарифмическая сложность (самая низкая!)

        //сортировка методом BubbleSort - сравниваем по 2 элемента, (i) с (i + 1)
        for (int i = 0; i < arr.length - 1; i++) { //Внешний цикл, который проходится по каждому элементу массива, за исключением последнего. Мы используем arr.length - 1, чтобы избежать выхода за пределы массива при сравнении элементов.
            for (int j = 0; j < arr.length - 1; j++) { //Внутренний цикл, который также проходится по каждому элементу массива, за исключением последнего. Этот цикл используется для сравнения соседних элементов.
                if (arr[j] > arr[j + 1]) { //Условие проверки: если текущий элемент больше следующего, то выполняем блок кода внутри условия.
                    //Переставим элементы местами
                    int temp = arr[j]; //Создаем временную переменную temp и сохраняем в нее значение текущего элемента.
                    arr[j] = arr[j + 1]; //Заменяем текущий элемент значением следующего элемента.
                    arr[j + 1] = temp; //Присваиваем следующему элементу значение временной переменной temp, тем самым завершая обмен значениями и сортировку.
                }
            }
        }
        System.out.println(Arrays.toString(arr));

        // это квадратичная сложность O(n^2)

        Arrays.sort(arr);
        System.out.println(Arrays.toString(arr));
        //сложность в методе Arrays.sort - полилинейная
    }


//    class MyComparator implements Comparator<Integer> {
//        @Override
//        public int compare(Integer n1, Integer n2) {
//            // сортировка в обратном порядке
//            return n2 - n1;
//        }
}